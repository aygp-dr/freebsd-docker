#+TITLE: FreeBSD Docker Image Repository Setup
#+AUTHOR: Your Name
#+DATE: 2024
#+PROPERTY: header-args :mkdirp t
#+STARTUP: overview

* Overview

This org file contains the complete FreeBSD Docker image repository structure.
Tangle this file to generate all necessary files and directories.

#+begin_src bash :tangle no
# To tangle all files:
# M-x org-babel-tangle
# or
# C-c C-v t

# From command line:
emacs --batch -l org --eval "(org-babel-tangle-file \"setup.org\")"
#+end_src

* Architecture

#+begin_src mermaid :tangle no :exports results :file architecture.png
graph TB
    subgraph "Host System"
        A[Docker Engine]
        B[Host Kernel]
    end
    
    subgraph "Docker Container"
        C[Alpine Linux Base]
        D[QEMU Process]
        E[Virtual Hardware]
    end
    
    subgraph "FreeBSD VM"
        F[FreeBSD Kernel]
        G[FreeBSD Userland]
        H[Services]
    end
    
    A --> C
    B --> A
    C --> D
    D --> E
    E --> F
    F --> G
    G --> H
    
    style A fill:#f96
    style D fill:#69f
    style F fill:#6f9
#+end_src

* Core Docker Files

** Dockerfile

The main Dockerfile that builds our FreeBSD QEMU image.

#+begin_src dockerfile :tangle Dockerfile
FROM alpine:3.19

# Build arguments
ARG FREEBSD_VERSION=14.0-RELEASE
ARG QEMU_VERSION=8.2.0

# Install QEMU and dependencies
RUN apk add --no-cache \
    qemu-system-x86_64 \
    qemu-img \
    curl \
    socat \
    bash \
    coreutils \
    openssh-client \
    python3 \
    py3-pip

# Create work directory
WORKDIR /freebsd

# Download FreeBSD ISO
RUN ARCH="amd64" && \
    VERSION="${FREEBSD_VERSION}" && \
    ISO_URL="https://download.freebsd.org/releases/${ARCH}/${VERSION}/FreeBSD-${VERSION}-${ARCH}-disc1.iso" && \
    curl -L -o freebsd.iso "${ISO_URL}"

# Copy configuration files
COPY scripts/ /scripts/
COPY config/ /config/

# Make scripts executable
RUN chmod +x /scripts/*

# Create disk image
RUN qemu-img create -f qcow2 /freebsd/disk.qcow2 10G

# Install FreeBSD (automated)
RUN /scripts/install-freebsd.sh

# Expose ports
EXPOSE 22 80 443 8080

# Default environment variables
ENV MEMORY=1G \
    CPUS=2 \
    DISK_SIZE=10G \
    SSH_PORT=22

# Health check
HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
    CMD /scripts/health-check.sh || exit 1

# Entrypoint
ENTRYPOINT ["/scripts/entrypoint.sh"]
CMD ["start"]
#+end_src

** Docker Compose

#+begin_src yaml :tangle docker-compose.yml
version: '3.8'

services:
  freebsd:
    build:
      context: .
      args:
        FREEBSD_VERSION: ${FREEBSD_VERSION:-14.0-RELEASE}
    image: ${DOCKER_HUB_USER:-yourusername}/freebsd:${FREEBSD_VERSION:-14.0-RELEASE}
    container_name: freebsd-vm
    privileged: true
    ports:
      - "2222:22"     # SSH
      - "8080:80"     # HTTP
      - "8443:443"    # HTTPS
    environment:
      - MEMORY=${MEMORY:-2G}
      - CPUS=${CPUS:-2}
      - DISK_SIZE=${DISK_SIZE:-10G}
    volumes:
      # Mount workspace for development
      - ./workspace:/workspace:rw
      # Persist VM disk between restarts (optional)
      # - freebsd-disk:/freebsd
    restart: unless-stopped
    healthcheck:
      test: ["/scripts/health-check.sh"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  # Optional: Add a development container that connects to FreeBSD
  dev:
    image: alpine:3.19
    container_name: freebsd-dev
    depends_on:
      freebsd:
        condition: service_healthy
    volumes:
      - ./workspace:/workspace:rw
    environment:
      - FREEBSD_HOST=freebsd
      - FREEBSD_SSH_PORT=22
    command: |
      sh -c "
        apk add --no-cache openssh-client bash python3 &&
        echo 'FreeBSD dev environment ready' &&
        tail -f /dev/null
      "

volumes:
  freebsd-disk:
    driver: local

networks:
  default:
    name: freebsd-network
#+end_src

** Docker Ignore

#+begin_src text :tangle .dockerignore
# Git files
.git/
.gitignore
.github/

# Documentation
README.md
CONTRIBUTING.md
LICENSE
docs/

# Development files
Makefile
docker-compose.yml
.env
.env.local

# Test files
tests/
*.test.sh

# CI/CD
.github/
.gitlab-ci.yml

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Build artifacts
*.log
*.tmp
.cache/

# Python files (if any scripts)
__pycache__/
*.pyc
*.pyo
.venv/
venv/

# Org-mode files
*.org
.org-id-locations
#+end_src

* Scripts

** Entrypoint Script

#+begin_src bash :tangle scripts/entrypoint.sh :shebang "#!/bin/bash"
set -e

# Configuration
MEMORY="${MEMORY:-1G}"
CPUS="${CPUS:-2}"
SSH_PORT="${SSH_PORT:-22}"
VNC_PORT="${VNC_PORT:-5900}"

# QEMU options
QEMU_OPTS=(
    -name "FreeBSD-Docker"
    -m "${MEMORY}"
    -smp "${CPUS}"
    -enable-kvm
    -cpu host
    -drive "file=/freebsd/disk.qcow2,format=qcow2,if=virtio"
    -netdev "user,id=net0,hostfwd=tcp::${SSH_PORT}-:22"
    -device "virtio-net,netdev=net0"
    -nographic
    -serial mon:stdio
)

# Function to wait for FreeBSD to boot
wait_for_boot() {
    echo "Waiting for FreeBSD to boot..."
    for i in {1..60}; do
        if nc -z localhost "${SSH_PORT}" 2>/dev/null; then
            echo "FreeBSD is ready!"
            return 0
        fi
        sleep 2
    done
    echo "Timeout waiting for FreeBSD to boot"
    return 1
}

# Function to start QEMU
start_vm() {
    echo "Starting FreeBSD VM..."
    echo "Memory: ${MEMORY}"
    echo "CPUs: ${CPUS}"
    echo "SSH Port: ${SSH_PORT}"
    
    # Check if KVM is available
    if [ ! -e /dev/kvm ]; then
        echo "Warning: KVM not available, running without acceleration"
        QEMU_OPTS=("${QEMU_OPTS[@]//-enable-kvm/}")
        QEMU_OPTS=("${QEMU_OPTS[@]//-cpu host/-cpu qemu64}")
    fi
    
    # Start QEMU in background
    qemu-system-x86_64 "${QEMU_OPTS[@]}" &
    QEMU_PID=$!
    
    # Wait for boot
    if wait_for_boot; then
        echo "FreeBSD VM started successfully"
        # Keep container running
        wait $QEMU_PID
    else
        echo "Failed to start FreeBSD VM"
        kill $QEMU_PID 2>/dev/null
        exit 1
    fi
}

# Function to connect via SSH
connect_ssh() {
    wait_for_boot
    ssh -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -p "${SSH_PORT}" \
        root@localhost
}

# Main logic
case "${1}" in
    start)
        start_vm
        ;;
    ssh)
        connect_ssh
        ;;
    shell)
        /bin/bash
        ;;
    *)
        echo "Usage: ${0} {start|ssh|shell}"
        echo "  start - Start FreeBSD VM"
        echo "  ssh   - Connect to FreeBSD via SSH"
        echo "  shell - Drop into container shell"
        exit 1
        ;;
esac
#+end_src

** Installation Script

#+begin_src bash :tangle scripts/install-freebsd.sh :shebang "#!/bin/bash"
set -e

echo "Starting automated FreeBSD installation..."

# Create installer configuration
cat > /tmp/installerconfig << 'EOF'
# FreeBSD Installer Configuration

# Partition scheme
PARTITIONS="AUTO"

# Root password (change in production!)
echo 'freebsd' | pw usermod root -h 0

# Enable SSH
echo 'sshd_enable="YES"' >> /etc/rc.conf
echo 'PermitRootLogin yes' >> /etc/ssh/sshd_config

# Configure network
echo 'ifconfig_vtnet0="DHCP"' >> /etc/rc.conf

# Set hostname
echo 'hostname="freebsd-docker"' >> /etc/rc.conf

# Install minimal packages
env ASSUME_ALWAYS_YES=YES pkg bootstrap
pkg install -y \
    bash \
    curl \
    git \
    python3 \
    sudo \
    vim-lite

# Create a user
pw useradd -n docker -m -s /usr/local/bin/bash -G wheel
echo 'docker' | pw usermod docker -h 0

# Configure sudo
echo '%wheel ALL=(ALL) NOPASSWD: ALL' > /usr/local/etc/sudoers.d/wheel

# Clean up
pkg clean -y
EOF

# Run QEMU with installer
qemu-system-x86_64 \
    -m 2G \
    -smp 2 \
    -drive file=/freebsd/disk.qcow2,format=qcow2,if=virtio \
    -cdrom /freebsd/freebsd.iso \
    -boot d \
    -nographic \
    -serial mon:stdio \
    -display none \
    -monitor none \
    -no-reboot \
    -append "autoboot_delay=0 beastie_disable=YES loader_logo=none console=comconsole" \
    < /tmp/installerconfig || true

echo "FreeBSD installation completed"

# Clean up ISO to save space
rm -f /freebsd/freebsd.iso
#+end_src

** Health Check Script

#+begin_src bash :tangle scripts/health-check.sh :shebang "#!/bin/bash"
# Check if QEMU process is running
if ! pgrep -f "qemu-system-x86_64" > /dev/null; then
    echo "QEMU process not running"
    exit 1
fi

# Check if SSH port is accessible
if ! nc -z localhost "${SSH_PORT:-22}" 2>/dev/null; then
    echo "SSH port not accessible"
    exit 1
fi

echo "FreeBSD VM is healthy"
exit 0
#+end_src

* Build System

** Makefile

#+begin_src makefile :tangle Makefile
# Makefile for FreeBSD Docker Image

# Variables
DOCKER_HUB_USER ?= yourusername
IMAGE_NAME = freebsd
VERSION ?= 14.0-RELEASE
TAG = $(VERSION)
FULL_IMAGE = $(DOCKER_HUB_USER)/$(IMAGE_NAME):$(TAG)
LATEST_IMAGE = $(DOCKER_HUB_USER)/$(IMAGE_NAME):latest

# Build arguments
BUILD_ARGS = --build-arg FREEBSD_VERSION=$(VERSION)

# Platforms for multi-arch builds (only amd64 for now)
PLATFORMS = linux/amd64

.PHONY: help
help:
	@echo "FreeBSD Docker Image Management"
	@echo ""
	@echo "Available targets:"
	@echo "  build       - Build the Docker image"
	@echo "  push        - Push image to Docker Hub"
	@echo "  run         - Run the container interactively"
	@echo "  test        - Run tests"
	@echo "  clean       - Remove local images"
	@echo "  release     - Build and push a release"
	@echo ""
	@echo "Variables:"
	@echo "  VERSION     - FreeBSD version (default: $(VERSION))"
	@echo "  DOCKER_HUB_USER - Docker Hub username (default: $(DOCKER_HUB_USER))"

.PHONY: build
build:
	@echo "Building FreeBSD $(VERSION) Docker image..."
	docker build $(BUILD_ARGS) -t $(FULL_IMAGE) -t $(LATEST_IMAGE) .

.PHONY: build-nocache
build-nocache:
	@echo "Building FreeBSD $(VERSION) Docker image (no cache)..."
	docker build --no-cache $(BUILD_ARGS) -t $(FULL_IMAGE) -t $(LATEST_IMAGE) .

.PHONY: push
push:
	@echo "Pushing $(FULL_IMAGE) to Docker Hub..."
	docker push $(FULL_IMAGE)
	docker push $(LATEST_IMAGE)

.PHONY: run
run:
	@echo "Running FreeBSD $(VERSION) container..."
	docker run -it --rm --privileged \
		-e MEMORY=2G \
		-e CPUS=2 \
		-p 2222:22 \
		$(FULL_IMAGE)

.PHONY: run-detached
run-detached:
	@echo "Running FreeBSD $(VERSION) container in background..."
	docker run -d --privileged \
		--name freebsd-vm \
		-e MEMORY=2G \
		-e CPUS=2 \
		-p 2222:22 \
		$(FULL_IMAGE)

.PHONY: ssh
ssh:
	@echo "Connecting to FreeBSD container..."
	ssh -o StrictHostKeyChecking=no \
		-o UserKnownHostsFile=/dev/null \
		-p 2222 \
		root@localhost

.PHONY: test
test:
	@echo "Running tests..."
	./tests/run-tests.sh

.PHONY: clean
clean:
	@echo "Removing local images..."
	docker rmi -f $(FULL_IMAGE) $(LATEST_IMAGE) || true
	docker container prune -f

.PHONY: release
release: build test push
	@echo "Release $(VERSION) completed!"

# Multi-version builds
.PHONY: build-all
build-all:
	$(MAKE) build VERSION=14.0-RELEASE
	$(MAKE) build VERSION=13.2-RELEASE
	$(MAKE) build VERSION=13.1-RELEASE

.PHONY: push-all
push-all:
	$(MAKE) push VERSION=14.0-RELEASE
	$(MAKE) push VERSION=13.2-RELEASE
	$(MAKE) push VERSION=13.1-RELEASE

# Development helpers
.PHONY: shell
shell:
	docker run -it --rm --privileged $(FULL_IMAGE) shell

.PHONY: logs
logs:
	docker logs -f freebsd-vm
#+end_src

* CI/CD

** GitHub Actions Workflow

#+begin_src yaml :tangle .github/workflows/build.yml
name: Build and Publish FreeBSD Docker Image

on:
  push:
    branches:
      - main
      - develop
    tags:
      - 'v*'
  pull_request:
    branches:
      - main
  schedule:
    # Weekly builds to keep image fresh
    - cron: '0 0 * * 0'
  workflow_dispatch:

env:
  REGISTRY: docker.io
  IMAGE_NAME: ${{ secrets.DOCKER_HUB_USERNAME }}/freebsd

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version:
          - '14.0-RELEASE'
          - '13.2-RELEASE'
          - '13.1-RELEASE'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Docker Hub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=${{ matrix.version }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            FREEBSD_VERSION=${{ matrix.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  test:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Test FreeBSD container
        run: |
          # Run basic tests
          docker run --rm --privileged \
            ${{ env.IMAGE_NAME }}:14.0-RELEASE \
            /scripts/health-check.sh

  security-scan:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    
    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_NAME }}:latest
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

  update-readme:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Update Docker Hub README
        uses: peter-evans/dockerhub-description@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}
          repository: ${{ secrets.DOCKER_HUB_USERNAME }}/freebsd
          readme-filepath: ./README.md
#+end_src

* Configuration

** FreeBSD Configuration Template

#+begin_src conf :tangle config/freebsd.conf.template
# FreeBSD Configuration Template
# This file can be used to customize the FreeBSD installation

# Package list to install
PACKAGES="
bash
curl
git
python39
vim-lite
tmux
htop
wget
rsync
"

# RC configuration entries
RC_CONF="
sshd_enable=\"YES\"
hostname=\"freebsd-docker\"
ifconfig_vtnet0=\"DHCP\"
ntpd_enable=\"YES\"
"

# Sysctl settings
SYSCTL_CONF="
# Network performance
kern.ipc.somaxconn=1024
net.inet.tcp.sendspace=65536
net.inet.tcp.recvspace=65536
"

# User configuration
USERS="
docker:wheel:Docker User
developer:wheel:Development User
"

# Custom startup script
STARTUP_SCRIPT='
#!/bin/sh
# Custom startup commands
echo "FreeBSD Docker container started at $(date)" >> /var/log/startup.log
'
#+end_src

* Testing

** Test Runner

#+begin_src bash :tangle tests/run-tests.sh :shebang "#!/bin/bash"
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Test configuration
TEST_IMAGE="${TEST_IMAGE:-yourusername/freebsd:14.0-RELEASE}"
TEST_SUITE="${1:-all}"

# Functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

# Test: Docker image builds successfully
test_docker_build() {
    log_info "Testing Docker build..."
    
    if docker build -t test-freebsd:latest .; then
        log_info "✓ Docker build successful"
        return 0
    else
        log_error "✗ Docker build failed"
        return 1
    fi
}

# Test: Container starts successfully
test_container_start() {
    log_info "Testing container startup..."
    
    # Start container in background
    CONTAINER_ID=$(docker run -d --privileged --name test-freebsd-vm ${TEST_IMAGE} || echo "failed")
    
    if [ "$CONTAINER_ID" = "failed" ]; then
        log_error "✗ Failed to start container"
        return 1
    fi
    
    # Wait for container to be healthy
    for i in {1..30}; do
        if docker exec test-freebsd-vm /scripts/health-check.sh 2>/dev/null; then
            log_info "✓ Container started and healthy"
            docker stop test-freebsd-vm >/dev/null
            docker rm test-freebsd-vm >/dev/null
            return 0
        fi
        sleep 2
    done
    
    log_error "✗ Container failed health check"
    docker stop test-freebsd-vm >/dev/null 2>&1
    docker rm test-freebsd-vm >/dev/null 2>&1
    return 1
}

# Test: QEMU runs inside container
test_qemu_running() {
    log_info "Testing QEMU process..."
    
    CONTAINER_ID=$(docker run -d --privileged --name test-qemu ${TEST_IMAGE})
    sleep 10
    
    if docker exec test-qemu pgrep -f "qemu-system-x86_64" >/dev/null 2>&1; then
        log_info "✓ QEMU process is running"
        docker stop test-qemu >/dev/null
        docker rm test-qemu >/dev/null
        return 0
    else
        log_error "✗ QEMU process not found"
        docker stop test-qemu >/dev/null 2>&1
        docker rm test-qemu >/dev/null 2>&1
        return 1
    fi
}

# Test: Scripts are executable
test_scripts_executable() {
    log_info "Testing script permissions..."
    
    local failed=0
    for script in entrypoint.sh install-freebsd.sh health-check.sh; do
        if docker run --rm ${TEST_IMAGE} test -x /scripts/${script}; then
            log_info "✓ ${script} is executable"
        else
            log_error "✗ ${script} is not executable"
            failed=1
        fi
    done
    
    return $failed
}

# Test: Environment variables work
test_environment_vars() {
    log_info "Testing environment variables..."
    
    OUTPUT=$(docker run --rm -e MEMORY=4G -e CPUS=4 ${TEST_IMAGE} bash -c 'echo "Memory: $MEMORY, CPUs: $CPUS"')
    
    if [[ "$OUTPUT" == *"Memory: 4G, CPUs: 4"* ]]; then
        log_info "✓ Environment variables working"
        return 0
    else
        log_error "✗ Environment variables not working"
        return 1
    fi
}

# Main test runner
main() {
    log_info "Starting FreeBSD Docker image tests..."
    log_info "Test suite: ${TEST_SUITE}"
    log_info "Test image: ${TEST_IMAGE}"
    
    local total=0
    local passed=0
    local failed=0
    
    # Define test suites
    case "${TEST_SUITE}" in
        build)
            TESTS=(test_docker_build)
            ;;
        runtime)
            TESTS=(test_container_start test_qemu_running test_environment_vars)
            ;;
        scripts)
            TESTS=(test_scripts_executable)
            ;;
        all|*)
            TESTS=(test_docker_build test_scripts_executable test_environment_vars)
            # Skip runtime tests in CI due to privileged requirement
            if [ -z "$CI" ]; then
                TESTS+=(test_container_start test_qemu_running)
            fi
            ;;
    esac
    
    # Run tests
    for test in "${TESTS[@]}"; do
        echo ""
        ((total++))
        if $test; then
            ((passed++))
        else
            ((failed++))
        fi
    done
    
    # Summary
    echo ""
    echo "========================================"
    log_info "Test Summary:"
    log_info "Total tests: ${total}"
    log_info "Passed: ${passed}"
    if [ $failed -gt 0 ]; then
        log_error "Failed: ${failed}"
    else
        log_info "Failed: ${failed}"
    fi
    echo "========================================"
    
    # Exit with appropriate code
    if [ $failed -gt 0 ]; then
        exit 1
    else
        log_info "All tests passed!"
        exit 0
    fi
}

# Run main
main
#+end_src

* Documentation

** README

#+begin_src markdown :tangle README.md
# FreeBSD Docker Image

Run FreeBSD in Docker using QEMU virtualization. This is useful for CI/CD, testing, and development scenarios where you need FreeBSD but only have Linux/Docker infrastructure.

## ⚠️ Important Notes

- This runs a full FreeBSD VM inside Docker using QEMU
- Performance overhead is significant compared to native containers
- Requires `--privileged` flag or specific capabilities
- Not suitable for production workloads

## Quick Start

```bash
# Pull from Docker Hub
docker pull yourusername/freebsd:14.0-RELEASE

# Run interactively
docker run -it --rm --privileged yourusername/freebsd:14.0-RELEASE

# Run with custom memory
docker run -it --rm --privileged -e MEMORY=2G yourusername/freebsd:14.0-RELEASE
```

## Architecture

```mermaid
graph TD
    A[Docker Container] --> B[QEMU Process]
    B --> C[FreeBSD VM]
    C --> D[FreeBSD Kernel]
    D --> E[FreeBSD Userland]
    
    F[Host Kernel] --> A
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style C fill:#9ff,stroke:#333,stroke-width:2px
```

## Building

```bash
# Build locally
make build

# Build specific version
make build VERSION=13.2-RELEASE

# Push to Docker Hub
make push
```

## Supported Versions

- FreeBSD 14.0-RELEASE (default)
- FreeBSD 13.2-RELEASE
- FreeBSD 13.1-RELEASE

## Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `MEMORY` | VM memory allocation | `1G` |
| `CPUS` | Number of CPU cores | `2` |
| `DISK_SIZE` | Virtual disk size | `10G` |
| `SSH_PORT` | SSH port mapping | `2222` |

## Use Cases

### CI/CD Testing
```yaml
# .github/workflows/test-freebsd.yml
- name: Test on FreeBSD
  run: |
    docker run --rm --privileged \
      -v $PWD:/workspace \
      yourusername/freebsd:14.0-RELEASE \
      /workspace/run-tests.sh
```

### Development Environment
```bash
# Mount local directory
docker run -it --rm --privileged \
  -v $PWD:/workspace \
  -p 2222:22 \
  yourusername/freebsd:14.0-RELEASE
```

## Contributing

See [CONTRIBUTING.md](CONTRIBUTING.md) for development setup and guidelines.

## License

MIT - See [LICENSE](LICENSE)
#+end_src

** Contributing Guide

#+begin_src markdown :tangle CONTRIBUTING.md
# Contributing to FreeBSD Docker Image

Thank you for your interest in contributing! This guide will help you get started.

## Development Setup

### Prerequisites

- Docker 24.0+
- Make
- Python 3.8+ (for testing scripts)
- Git

### Getting Started

```bash
# Clone the repository
git clone https://github.com/yourusername/freebsd-docker.git
cd freebsd-docker

# Build the image locally
make build

# Run tests
make test

# Run the container
make run
```

## Development Workflow

```mermaid
graph LR
    A[Fork Repository] --> B[Create Feature Branch]
    B --> C[Make Changes]
    C --> D[Test Locally]
    D --> E[Commit Changes]
    E --> F[Push to Fork]
    F --> G[Create Pull Request]
    G --> H[CI/CD Tests]
    H --> I[Code Review]
    I --> J[Merge]
```

## Project Structure

```
freebsd-docker/
├── Dockerfile              # Main Docker image definition
├── Makefile               # Build and management commands
├── docker-compose.yml     # Local development setup
├── scripts/               # Container runtime scripts
│   ├── entrypoint.sh     # Main entry point
│   ├── install-freebsd.sh # Automated installation
│   └── health-check.sh   # Health check script
├── config/               # Configuration files
├── tests/                # Test suite
├── docs/                 # Additional documentation
└── .github/              # GitHub Actions workflows
```

## Testing

### Running Tests Locally

```bash
# Run all tests
make test

# Run specific test suite
./tests/run-tests.sh --suite integration

# Test with different FreeBSD versions
make test VERSION=13.2-RELEASE
```

### Test Coverage

- Unit tests for scripts
- Integration tests for Docker build
- Smoke tests for FreeBSD functionality
- Security scanning with Trivy

## Coding Standards

### Shell Scripts

- Use `#!/bin/bash` for consistency
- Set `set -e` for error handling
- Use meaningful variable names
- Add comments for complex logic

### Documentation

We use org-mode compatible markdown with Mermaid diagrams:

```org
#+TITLE: Feature Documentation
#+AUTHOR: Your Name

* Overview
Description of the feature

** Architecture
#+begin_src mermaid
graph TD
    A[Component A] --> B[Component B]
#+end_src

** Implementation
#+begin_src bash :tangle scripts/feature.sh :mkdirp t
#!/bin/bash
# Feature implementation
#+end_src
```

## Submitting Changes

### Commit Messages

Follow the conventional commits format:

```
type(scope): description

[optional body]

[optional footer]
```

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

### Pull Request Process

1. Update documentation if needed
2. Add tests for new functionality
3. Ensure all tests pass
4. Update the CHANGELOG.md
5. Request review from maintainers

## Release Process

```mermaid
sequenceDiagram
    participant D as Developer
    participant G as GitHub
    participant A as Actions
    participant H as Docker Hub
    
    D->>G: Push tag (v1.0.0)
    G->>A: Trigger workflow
    A->>A: Build images
    A->>A: Run tests
    A->>H: Push images
    A->>G: Create release
```

## Adding FreeBSD Versions

To add support for a new FreeBSD version:

1. Update `Dockerfile` with new version option
2. Add version to build matrix in `.github/workflows/build.yml`
3. Test the new version locally
4. Update documentation

## Security

- Report security issues privately to maintainers
- Don't commit sensitive data
- Use environment variables for secrets
- Keep dependencies updated

## Questions?

- Open an issue for bugs or features
- Join discussions for questions
- Check existing issues before creating new ones

Thank you for contributing!
#+end_src

** Quick Start Guide

#+begin_src markdown :tangle docs/quick-start.md
# FreeBSD Docker Quick Start Guide

## Architecture Overview

```mermaid
graph TB
    subgraph "Host System"
        A[Docker Engine]
        B[Host Kernel]
    end
    
    subgraph "Docker Container"
        C[Alpine Linux Base]
        D[QEMU Process]
        E[Virtual Hardware]
    end
    
    subgraph "FreeBSD VM"
        F[FreeBSD Kernel]
        G[FreeBSD Userland]
        H[Services<br/>SSH, HTTP, etc]
    end
    
    subgraph "Storage"
        I[disk.qcow2<br/>Virtual Disk]
    end
    
    A --> C
    B --> A
    C --> D
    D --> E
    E --> F
    F --> G
    G --> H
    D --> I
    
    style A fill:#f96
    style D fill:#69f
    style F fill:#6f9
```

## Quick Commands

### Basic Usage

```bash
# Pull and run
docker run -it --rm --privileged yourusername/freebsd:14.0-RELEASE

# Run with custom resources
docker run -it --rm --privileged \
    -e MEMORY=4G \
    -e CPUS=4 \
    yourusername/freebsd:14.0-RELEASE

# Run in background with SSH access
docker run -d --privileged \
    --name my-freebsd \
    -p 2222:22 \
    yourusername/freebsd:14.0-RELEASE

# Connect via SSH (password: freebsd)
ssh -p 2222 root@localhost
```

### Using Docker Compose

```bash
# Start FreeBSD VM
docker-compose up -d

# View logs
docker-compose logs -f

# Connect to VM
docker-compose exec freebsd bash

# Stop VM
docker-compose down
```

### Development Workflow

```bash
# Clone repository
git clone https://github.com/yourusername/freebsd-docker.git
cd freebsd-docker

# Build custom image
make build

# Run with workspace mounted
docker run -it --rm --privileged \
    -v $PWD/workspace:/workspace \
    yourusername/freebsd:14.0-RELEASE
```

## Performance Tips

1. **Enable KVM**: Ensure KVM is available on Linux hosts for hardware acceleration
   ```bash
   # Check KVM support
   ls -la /dev/kvm
   ```

2. **Allocate Sufficient Resources**:
   - Minimum: 1GB RAM, 2 CPUs
   - Recommended: 2GB+ RAM, 4 CPUs

3. **Use SSD Storage**: Place Docker data directory on SSD for better I/O performance

4. **Persistent Storage**: Use volumes to persist the VM disk between restarts
   ```yaml
   volumes:
     - freebsd-disk:/freebsd
   ```

## Troubleshooting

### Container won't start
- Check if running with `--privileged` flag
- Verify Docker has enough resources allocated
- Check logs: `docker logs container-name`

### SSH connection refused
- Wait 30-60 seconds for FreeBSD to boot
- Check if port 2222 is already in use
- Verify container health: `docker exec container-name /scripts/health-check.sh`

### Poor performance
- Enable KVM acceleration (Linux hosts)
- Increase memory allocation
- Check host system resources

## Customization

### Installing Additional Packages

```bash
# Inside FreeBSD VM
pkg install -y nginx postgresql15-server node20

# Or during build (modify Dockerfile)
RUN pkg install -y your-packages
```

### Changing Default Settings

Edit `/config/freebsd.conf.template` before building to customize:
- Package list
- Network configuration  
- User accounts
- System settings

### Building Custom Versions

```bash
# Build specific FreeBSD version
make build VERSION=13.2-RELEASE

# Build with custom parameters
docker build \
    --build-arg FREEBSD_VERSION=14.0-RELEASE \
    --build-arg DISK_SIZE=20G \
    -t my-custom-freebsd .
```

## Security Considerations

- Default root password is 'freebsd' - change it!
- Container runs with --privileged flag
- Consider network isolation for production use
- Regularly update base image and FreeBSD

## Next Steps

- Read the full [README.md](../README.md)
- Check [CONTRIBUTING.md](../CONTRIBUTING.md) for development
- Explore example use cases in `/docs/examples/`
- Join the community discussions
#+end_src

* Supporting Files

** License

#+begin_src text :tangle LICENSE
MIT License

Copyright (c) 2024 [Your Name]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
#+end_src

** Git Ignore

#+begin_src text :tangle .gitignore
# OS files
.DS_Store
Thumbs.db
*.swp
*.swo
*~

# IDE files
.vscode/
.idea/
*.iml
.project
.settings/

# Build artifacts
*.log
*.tmp
.cache/
build/
dist/

# Docker
.env
.env.local
docker-compose.override.yml

# Python
__pycache__/
*.py[cod]
*$py.class
.venv/
venv/
env/
.Python

# Org-mode
*.org
.org-id-locations
*_archive

# Test artifacts
test-results/
coverage/
.coverage
htmlcov/

# Workspace
workspace/*
!workspace/.gitkeep

# FreeBSD disk images (if persisted locally)
*.qcow2
*.img
*.iso

# Temporary files
temp/
tmp/
*.bak
*.orig

# Secrets
secrets/
*.key
*.pem
*.crt
#+end_src

** Workspace Placeholder

#+begin_src text :tangle workspace/.gitkeep
# This directory is mounted into the FreeBSD container at /workspace
#+end_src

* Usage Instructions

** Tangling the Repository

To generate all files from this org document:

#+begin_src bash :tangle no
# In Emacs:
M-x org-babel-tangle

# Or from command line:
emacs --batch -l org --eval "(org-babel-tangle-file \"setup.org\")"

# Or create a simple tangle script:
cat > tangle.sh << 'EOF'
#!/bin/bash
emacs --batch -l org --eval "(org-babel-tangle-file \"$1\")"
EOF
chmod +x tangle.sh
./tangle.sh setup.org
#+end_src

** Post-Tangle Setup

After tangling, run these commands:

#+begin_src bash :tangle no
# Make scripts executable
chmod +x scripts/*.sh
chmod +x tests/*.sh

# Initialize git repository
git init
git add .
git commit -m "Initial commit: FreeBSD Docker image from org-mode setup"

# Build the image
make build

# Run tests
make test
#+end_src

** Customization

1. Update `yourusername` throughout the file with your Docker Hub username
2. Modify the FreeBSD versions as needed
3. Adjust resource defaults in environment variables
4. Add any additional packages or configurations

* Conclusion

This org-mode file contains the complete FreeBSD Docker repository structure. 
Tangle it to generate all necessary files, then follow the setup instructions to build and deploy your FreeBSD Docker image.

The beauty of this approach is that you have your entire infrastructure defined in a single, literate programming document that can be version controlled, documented, and regenerated at will.
#+end_src
